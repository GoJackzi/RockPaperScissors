{
  "language": "Solidity",
  "sources": {
    "contracts/RockPaperScissors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"@fhevm/solidity/lib/FHE.sol\";\nimport {SepoliaConfig} from \"@fhevm/solidity/config/ZamaConfig.sol\";\nimport \"@fhevm/solidity/lib/Impl.sol\";\n\n/// @title Encrypted Rock Paper Scissors Game\n/// @notice A privacy-preserving rock paper scissors game using Zama's FHEVM\n/// @dev Uses Fully Homomorphic Encryption to keep moves private until both players commit\ncontract RockPaperScissors is SepoliaConfig {\n    // Move encoding: 0 = Rock, 1 = Paper, 2 = Scissors\n    \n    enum GameStatus {\n        WaitingForPlayers,\n        WaitingForMoves,\n        MovesCommitted,\n        DecryptionInProgress,\n        ResultsDecrypted\n    }\n    \n    struct Game {\n        address player1;\n        address player2;\n        euint8 encryptedMove1;\n        euint8 encryptedMove2;\n        bool player1Committed;\n        bool player2Committed;\n        GameStatus status;\n        uint256 createdAt;\n        uint256 requestId;\n        \n        // Decrypted results (only available after decryption)\n        bool isDraw;\n        bool player1Wins;\n        bool resultsDecrypted;\n    }\n    \n    mapping(uint256 => Game) public games;\n    mapping(uint256 => uint256) public requestIdToGameId; // Map request ID to game ID\n    uint256 public gameCounter;\n    \n    // FHEVM v0.8.1 compliance: Access control\n    modifier onlyGatewayOracle() {\n        // In FHEVM v0.8.1, the decryption oracle is handled by the FHEVM system\n        // This modifier ensures only the FHEVM oracle can call the callback\n        require(msg.sender == address(this) || msg.sender.code.length == 0, \"Only oracle can call this\");\n        _;\n    }\n    \n    modifier onlyPlayer(uint256 gameId) {\n        Game storage game = games[gameId];\n        require(\n            msg.sender == game.player1 || msg.sender == game.player2,\n            \"Only players can perform this action\"\n        );\n        _;\n    }\n    \n    event GameCreated(uint256 indexed gameId, address indexed player1);\n    event PlayerJoined(uint256 indexed gameId, address indexed player2);\n    event MoveMade(uint256 indexed gameId, address indexed player, bool isPlayer1);\n    event DecryptionRequested(uint256 indexed gameId, uint256 indexed requestId);\n    event GameFinished(uint256 indexed gameId, address winner, bool isDraw);\n    \n    constructor() {\n        // Initialize with any required setup\n    }\n    \n    /// @notice Create a new game\n    /// @return gameId The ID of the newly created game\n    function createGame() external returns (uint256) {\n        uint256 gameId = gameCounter++;\n        \n        games[gameId] = Game({\n            player1: msg.sender,\n            player2: address(0),\n            encryptedMove1: FHE.asEuint8(0),\n            encryptedMove2: FHE.asEuint8(0),\n            player1Committed: false,\n            player2Committed: false,\n            status: GameStatus.WaitingForPlayers,\n            createdAt: block.timestamp,\n            requestId: 0,\n            isDraw: false,\n            player1Wins: false,\n            resultsDecrypted: false\n        });\n        \n        // FHEVM v0.8 compliance: Allow encrypted variables for this contract\n        FHE.allowThis(games[gameId].encryptedMove1);\n        FHE.allowThis(games[gameId].encryptedMove2);\n        \n        emit GameCreated(gameId, msg.sender);\n        return gameId;\n    }\n    \n    /// @notice Join an existing game as player 2\n    /// @param gameId The ID of the game to join\n    function joinGame(uint256 gameId) external {\n        Game storage game = games[gameId];\n        require(game.player1 != address(0), \"Game does not exist\");\n        require(game.player2 == address(0), \"Game already has two players\");\n        require(game.player1 != msg.sender, \"Cannot play against yourself\");\n        require(game.status == GameStatus.WaitingForPlayers, \"Game not in waiting state\");\n        \n        game.player2 = msg.sender;\n        game.status = GameStatus.WaitingForMoves;\n        \n        emit PlayerJoined(gameId, msg.sender);\n    }\n    \n    /// @notice Submit an encrypted move\n    /// @param gameId The ID of the game\n    /// @param encryptedMove The encrypted move (0=rock, 1=paper, 2=scissors)\n    /// @param inputProof The zero-knowledge proof for the encrypted input\n    function makeMove(\n        uint256 gameId,\n        externalEuint8 encryptedMove,\n        bytes calldata inputProof\n    ) external onlyPlayer(gameId) {\n        Game storage game = games[gameId];\n        require(game.status == GameStatus.WaitingForMoves, \"Game not accepting moves\");\n        \n        // Validate and convert the encrypted input\n        euint8 move = FHE.fromExternal(encryptedMove, inputProof);\n        \n        // FHEVM v0.8 compliance: Allow the encrypted move for this contract\n        FHE.allowThis(move);\n        \n        if (msg.sender == game.player1) {\n            require(!game.player1Committed, \"Player 1 already committed\");\n            game.encryptedMove1 = move;\n            game.player1Committed = true;\n            emit MoveMade(gameId, msg.sender, true);\n        } else {\n            require(!game.player2Committed, \"Player 2 already committed\");\n            game.encryptedMove2 = move;\n            game.player2Committed = true;\n            emit MoveMade(gameId, msg.sender, false);\n        }\n        \n        // If both players have committed, mark as ready for resolution\n        if (game.player1Committed && game.player2Committed) {\n            game.status = GameStatus.MovesCommitted;\n        }\n    }\n    \n    /// @notice Request decryption of game results using FHEVM v0.8 async pattern\n    /// @param gameId The ID of the game\n    function requestGameResolution(uint256 gameId) external onlyPlayer(gameId) {\n        Game storage game = games[gameId];\n        require(game.status == GameStatus.MovesCommitted, \"Game not ready for resolution\");\n        require(game.requestId == 0, \"Resolution already requested\");\n        \n        // Determine winner using FHE operations\n        euint8 move1 = game.encryptedMove1;\n        euint8 move2 = game.encryptedMove2;\n        \n        // Check if moves are equal (draw)\n        ebool isDrawEncrypted = FHE.eq(move1, move2);\n        \n        // Player 1 wins if:\n        // (move1 == 0 && move2 == 2) || (move1 == 1 && move2 == 0) || (move1 == 2 && move2 == 1)\n        ebool move1IsRock = FHE.eq(move1, FHE.asEuint8(0));\n        ebool move2IsScissors = FHE.eq(move2, FHE.asEuint8(2));\n        ebool rockBeatsScissors = FHE.and(move1IsRock, move2IsScissors);\n        \n        ebool move1IsPaper = FHE.eq(move1, FHE.asEuint8(1));\n        ebool move2IsRock = FHE.eq(move2, FHE.asEuint8(0));\n        ebool paperBeatsRock = FHE.and(move1IsPaper, move2IsRock);\n        \n        ebool move1IsScissors = FHE.eq(move1, FHE.asEuint8(2));\n        ebool move2IsPaper = FHE.eq(move2, FHE.asEuint8(1));\n        ebool scissorsBeatsPaper = FHE.and(move1IsScissors, move2IsPaper);\n        \n        ebool player1WinsEncrypted = FHE.or(FHE.or(rockBeatsScissors, paperBeatsRock), scissorsBeatsPaper);\n        \n        // FHEVM v0.8 compliance: Allow access to encrypted results for decryption\n        FHE.allowTransient(isDrawEncrypted, msg.sender);\n        FHE.allowTransient(player1WinsEncrypted, msg.sender);\n        \n        // FHEVM v0.8 compliance: Request async decryption\n        bytes32[] memory cts = new bytes32[](2);\n        cts[0] = FHE.toBytes32(isDrawEncrypted);\n        cts[1] = FHE.toBytes32(player1WinsEncrypted);\n        \n        uint256 requestId = FHE.requestDecryption(cts, this.gameResolutionCallback.selector);\n        game.requestId = requestId;\n        game.status = GameStatus.DecryptionInProgress;\n        requestIdToGameId[requestId] = gameId;\n        \n        emit DecryptionRequested(gameId, requestId);\n    }\n    \n    /// @notice FHEVM v0.8 compliant callback function for game resolution decryption\n    /// @param requestId The request ID from the decryption request\n    /// @param cleartexts The decrypted results\n    /// @param decryptionProof The decryption proof\n    function gameResolutionCallback(\n        uint256 requestId,\n        bytes memory cleartexts,\n        bytes memory decryptionProof\n    ) external onlyGatewayOracle {\n        // Find the game using the request ID mapping\n        uint256 gameId = requestIdToGameId[requestId];\n        require(gameId != 0 || games[0].requestId == requestId, \"Request ID not found\");\n        \n        Game storage game = games[gameId];\n        \n        // FHEVM v0.8 compliance: Verify the decryption signatures\n        FHE.checkSignatures(requestId, cleartexts, decryptionProof);\n        \n        // Decode the results\n        (bool isDraw, bool player1Wins) = abi.decode(cleartexts, (bool, bool));\n        \n        // Store the decrypted results\n        game.isDraw = isDraw;\n        game.player1Wins = player1Wins;\n        game.resultsDecrypted = true;\n        game.status = GameStatus.ResultsDecrypted;\n        \n        // FHEVM v0.8.1 compliance: Clean up request ID mapping to prevent replay attacks\n        delete requestIdToGameId[requestId];\n        game.requestId = 0;\n        \n        // Determine the winner\n        address winner = address(0);\n        if (!game.isDraw) {\n            winner = game.player1Wins ? game.player1 : game.player2;\n        }\n        \n        emit GameFinished(gameId, winner, isDraw);\n    }\n    \n    /// @notice Get game information\n    /// @param gameId The ID of the game\n    /// @return player1 Address of player 1\n    /// @return player2 Address of player 2\n    /// @return status Current game status\n    /// @return player1Committed Whether player 1 has committed their move\n    /// @return player2Committed Whether player 2 has committed their move\n    /// @return resultsDecrypted Whether results have been decrypted\n    function getGame(uint256 gameId) external view returns (\n        address player1,\n        address player2,\n        GameStatus status,\n        bool player1Committed,\n        bool player2Committed,\n        bool resultsDecrypted\n    ) {\n        Game storage game = games[gameId];\n        require(game.player1 != address(0), \"Game does not exist\");\n        \n        return (\n            game.player1,\n            game.player2,\n            game.status,\n            game.player1Committed,\n            game.player2Committed,\n            game.resultsDecrypted\n        );\n    }\n    \n    /// @notice Get decrypted game results (only available after decryption)\n    /// @param gameId The ID of the game\n    /// @return isDraw Whether the game was a draw\n    /// @return player1Wins Whether player 1 won\n    /// @return winner The address of the winner (address(0) for draw)\n    function getGameResults(uint256 gameId) external view returns (\n        bool isDraw,\n        bool player1Wins,\n        address winner\n    ) {\n        Game storage game = games[gameId];\n        require(game.player1 != address(0), \"Game does not exist\");\n        require(game.resultsDecrypted, \"Results not yet decrypted\");\n        \n        address winnerAddress = address(0);\n        if (!game.isDraw) {\n            winnerAddress = game.player1Wins ? game.player1 : game.player2;\n        }\n        \n        return (game.isDraw, game.player1Wins, winnerAddress);\n    }\n    \n    /// @notice Check if game is ready to be resolved\n    /// @param gameId The ID of the game\n    /// @return Whether both players have committed their moves\n    function isGameReady(uint256 gameId) external view returns (bool) {\n        Game storage game = games[gameId];\n        return game.player1Committed && game.player2Committed && game.status == GameStatus.MovesCommitted;\n    }\n    \n    /// @notice Get the current game counter\n    /// @return The current game counter value\n    function getGameCounter() external view returns (uint256) {\n        return gameCounter;\n    }\n    \n    /// @notice Get the request ID for a game (for debugging)\n    /// @param gameId The ID of the game\n    /// @return The request ID for decryption\n    function getGameRequestId(uint256 gameId) external view returns (uint256) {\n        return games[gameId].requestId;\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "cancun",
    "viaIR": true,
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ]
      }
    }
  }
}